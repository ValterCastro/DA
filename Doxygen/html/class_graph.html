<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a05c45e4efdf867792139ddf3628c0b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a05c45e4efdf867792139ddf3628c0b60">findVertex</a> (int id) const</td></tr>
<tr class="separator:a05c45e4efdf867792139ddf3628c0b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2f69946b29fee07c53cb6552c7690e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2d2f69946b29fee07c53cb6552c7690e">addVertex</a> (int id)</td></tr>
<tr class="separator:a2d2f69946b29fee07c53cb6552c7690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480675e98227b5cea4d990d301d43eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a480675e98227b5cea4d990d301d43eee">addVertex</a> (int id, double longitude, double latitude)</td></tr>
<tr class="separator:a480675e98227b5cea4d990d301d43eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f1e9e76bcadbd27addb9c5cc455226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a45f1e9e76bcadbd27addb9c5cc455226">tsp_backtrack</a> (vector&lt; int &gt; &amp;path, vector&lt; bool &gt; &amp;visited, double &amp;min_cost, double costSoFar)</td></tr>
<tr class="separator:a45f1e9e76bcadbd27addb9c5cc455226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac3915ab78762e537d45657e30429b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a74ac3915ab78762e537d45657e30429b">triangularApproximation</a> ()</td></tr>
<tr class="separator:a74ac3915ab78762e537d45657e30429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf65f343e3c67b1b783f82375884a8f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aaaf65f343e3c67b1b783f82375884a8f">prim</a> ()</td></tr>
<tr class="separator:aaaf65f343e3c67b1b783f82375884a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69281f435a52c341937ffddca5555f32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a69281f435a52c341937ffddca5555f32">minWeight</a> (vector&lt; double &gt; &amp;weights, vector&lt; bool &gt; &amp;inMST)</td></tr>
<tr class="separator:a69281f435a52c341937ffddca5555f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae425a227650e2270bd2f0f57281786bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae425a227650e2270bd2f0f57281786bc">dfs</a> (const vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;mst, <a class="el" href="class_vertex.html">Vertex</a> *v, vector&lt; bool &gt; &amp;visited, vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:ae425a227650e2270bd2f0f57281786bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0db3dbf1368e972e7c551f6084db62"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8b0db3dbf1368e972e7c551f6084db62">haversine</a> (double lat1, double lon1, double lat2, double lon2)</td></tr>
<tr class="separator:a8b0db3dbf1368e972e7c551f6084db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8680f19d7040f83a874d04dae72e6285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8680f19d7040f83a874d04dae72e6285">haveEdge</a> (int v1, int v2)</td></tr>
<tr class="separator:a8680f19d7040f83a874d04dae72e6285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4653f95b8dbec22cbf1b0e24e3e7dd16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4653f95b8dbec22cbf1b0e24e3e7dd16">totalDistance</a> (const vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:a4653f95b8dbec22cbf1b0e24e3e7dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b8f75055384d32f66433e26bd5a1fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a78b8f75055384d32f66433e26bd5a1fb">nearestNeighbor</a> (<a class="el" href="class_vertex.html">Vertex</a> *&amp;initial, <a class="el" href="class_vertex.html">Vertex</a> *&amp;current, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;path, int graphSize, double &amp;distance, bool all)</td></tr>
<tr class="separator:a78b8f75055384d32f66433e26bd5a1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfae99b65a95d5d51696cdda1cab1bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9bfae99b65a95d5d51696cdda1cab1bb">addEdge</a> (int sourc, int dest, double w)</td></tr>
<tr class="separator:a9bfae99b65a95d5d51696cdda1cab1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b0ee96fce900475b8971d7ba41bf80"><td class="memItemLeft" align="right" valign="top"><a id="a40b0ee96fce900475b8971d7ba41bf80" name="a40b0ee96fce900475b8971d7ba41bf80"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBidirectionalEdge</b> (int sourc, int dest, double w)</td></tr>
<tr class="separator:a40b0ee96fce900475b8971d7ba41bf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ebf994612209ea38b477f08ad47cbe"><td class="memItemLeft" align="right" valign="top"><a id="af4ebf994612209ea38b477f08ad47cbe" name="af4ebf994612209ea38b477f08ad47cbe"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:af4ebf994612209ea38b477f08ad47cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c561481b4dbc9c089eb349fc0c0fb95"><td class="memItemLeft" align="right" valign="top"><a id="a6c561481b4dbc9c089eb349fc0c0fb95" name="a6c561481b4dbc9c089eb349fc0c0fb95"></a>
std::unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexMap</b> () const</td></tr>
<tr class="separator:a6c561481b4dbc9c089eb349fc0c0fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7dfcef08a9286cf144902cd7e56940ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7dfcef08a9286cf144902cd7e56940ee">findVertexIdx</a> (const int &amp;id) const</td></tr>
<tr class="separator:a7dfcef08a9286cf144902cd7e56940ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7abf58446a9d0e8bac8d510d0d68d02f"><td class="memItemLeft" align="right" valign="top"><a id="a7abf58446a9d0e8bac8d510d0d68d02f" name="a7abf58446a9d0e8bac8d510d0d68d02f"></a>
set&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="separator:a7abf58446a9d0e8bac8d510d0d68d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ec8868ac2bcbbe23eef25b6786ba37"><td class="memItemLeft" align="right" valign="top"><a id="a75ec8868ac2bcbbe23eef25b6786ba37" name="a75ec8868ac2bcbbe23eef25b6786ba37"></a>
unordered_map&lt; int, <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexMap</b></td></tr>
<tr class="separator:a75ec8868ac2bcbbe23eef25b6786ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61864da69191c1896a25a708d1a02d"><td class="memItemLeft" align="right" valign="top"><a id="a9e61864da69191c1896a25a708d1a02d" name="a9e61864da69191c1896a25a708d1a02d"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>distMatrix</b> = nullptr</td></tr>
<tr class="separator:a9e61864da69191c1896a25a708d1a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memItemLeft" align="right" valign="top"><a id="a3ae09699c3616af3ebfcb1eb045f2b62" name="a3ae09699c3616af3ebfcb1eb045f2b62"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>pathMatrix</b> = nullptr</td></tr>
<tr class="separator:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9bfae99b65a95d5d51696cdda1cab1bb" name="a9bfae99b65a95d5d51696cdda1cab1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfae99b65a95d5d51696cdda1cab1bb">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to add an edge to the graph given the ids of the source and destination vertices and the weight of the edge. It has a complexity of O(1) as it uses a map for the lookup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The id of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The id of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge was added successfully, false if either the source or destination vertex does not exist. </dd></dl>

</div>
</div>
<a id="a2d2f69946b29fee07c53cb6552c7690e" name="a2d2f69946b29fee07c53cb6552c7690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2f69946b29fee07c53cb6552c7690e">&#9670;&#160;</a></span>addVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to add a vertex to the graph given its id. It has a complexity of O(1) as it uses a map for the lookup and insertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex was added successfully, false if a vertex with the same id already exists. </dd></dl>

</div>
</div>
<a id="a480675e98227b5cea4d990d301d43eee" name="a480675e98227b5cea4d990d301d43eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480675e98227b5cea4d990d301d43eee">&#9670;&#160;</a></span>addVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to add a vertex to the graph given its id, longitude, and latitude. It has a complexity of O(1) as it uses a map for the lookup and insertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to add. </td></tr>
    <tr><td class="paramname">longitude</td><td>The longitude of the vertex to add. </td></tr>
    <tr><td class="paramname">latitude</td><td>The latitude of the vertex to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex was added successfully, false if a vertex with the same id already exists. </dd></dl>

</div>
</div>
<a id="ae425a227650e2270bd2f0f57281786bc" name="ae425a227650e2270bd2f0f57281786bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae425a227650e2270bd2f0f57281786bc">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfs </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to perform a DFS on the graph starting from a given vertex. It has a complexity of O(V + E) where V is the number of vertices and E is the number of edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>The minimum spanning tree to perform the DFS on. </td></tr>
    <tr><td class="paramname">v</td><td>The vertex to start the DFS from. </td></tr>
    <tr><td class="paramname">visited</td><td>A vector to keep track of the visited vertices. </td></tr>
    <tr><td class="paramname">path</td><td>A vector to keep track of the path taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05c45e4efdf867792139ddf3628c0b60" name="a05c45e4efdf867792139ddf3628c0b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c45e4efdf867792139ddf3628c0b60">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is used to find a vertex in the graph given its id. It has a complexity of O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a7dfcef08a9286cf144902cd7e56940ee" name="a7dfcef08a9286cf144902cd7e56940ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfcef08a9286cf144902cd7e56940ee">&#9670;&#160;</a></span>findVertexIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findVertexIdx </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This function is used to find the index of a vertex in the graph given its id. It has a complexity of O(n) as it iterates over the vertex set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the vertex to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex if found, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a8680f19d7040f83a874d04dae72e6285" name="a8680f19d7040f83a874d04dae72e6285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8680f19d7040f83a874d04dae72e6285">&#9670;&#160;</a></span>haveEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::haveEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function checks if there exists an edge between two given vertices. Complexity: O(E) where E is the number of edges from the first vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The id of the first vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>The id of the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is an edge between the two vertices, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b0db3dbf1368e972e7c551f6084db62" name="a8b0db3dbf1368e972e7c551f6084db62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0db3dbf1368e972e7c551f6084db62">&#9670;&#160;</a></span>haversine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::haversine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function computes the geographical distance between two points given their latitudes and longitudes using the Haversine formula. Complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1,lon1</td><td>The latitude and longitude of the first point. </td></tr>
    <tr><td class="paramname">lat2,lon2</td><td>The latitude and longitude of the second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The geographical distance between the two points in meters. </dd></dl>

</div>
</div>
<a id="a69281f435a52c341937ffddca5555f32" name="a69281f435a52c341937ffddca5555f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69281f435a52c341937ffddca5555f32">&#9670;&#160;</a></span>minWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::minWeight </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>inMST</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function finds the vertex with the minimum weight edge in the graph that is not yet included in the MST. Complexity: O(V) where V is the number of vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>A vector of edge weights. </td></tr>
    <tr><td class="paramname">inMST</td><td>A vector indicating whether each vertex is in the MST. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex with the minimum weight edge not yet in the MST. </dd></dl>

</div>
</div>
<a id="a78b8f75055384d32f66433e26bd5a1fb" name="a78b8f75055384d32f66433e26bd5a1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b8f75055384d32f66433e26bd5a1fb">&#9670;&#160;</a></span>nearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::nearestNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>graphSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements the nearest neighbor heuristic for the traveling salesman problem. It starts from an initial vertex and repeatedly visits the unvisited vertex that is closest to the current vertex. Complexity: O(n^2) where n is the number of vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial,current</td><td>References to the initial and current <a class="el" href="class_vertex.html">Vertex</a> objects. </td></tr>
    <tr><td class="paramname">path</td><td>A vector of <a class="el" href="class_edge.html">Edge</a> pointers representing the path. </td></tr>
    <tr><td class="paramname">graphSize</td><td>The number of vertices in the graph. </td></tr>
    <tr><td class="paramname">distance</td><td>The total distance traveled so far. </td></tr>
    <tr><td class="paramname">all</td><td>A boolean indicating if all vertices have been visited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the path. </dd></dl>

</div>
</div>
<a id="aaaf65f343e3c67b1b783f82375884a8f" name="aaaf65f343e3c67b1b783f82375884a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf65f343e3c67b1b783f82375884a8f">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; Graph::prim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements Prim's algorithm to find a minimum spanning tree of the graph. It maintains a priority queue of edges to visit in order of their weights. Complexity: O(ElogE) where E is the number of edges in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="class_edge.html">Edge</a> pointers representing the edges included in the minimum spanning tree. </dd></dl>

</div>
</div>
<a id="a4653f95b8dbec22cbf1b0e24e3e7dd16" name="a4653f95b8dbec22cbf1b0e24e3e7dd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4653f95b8dbec22cbf1b0e24e3e7dd16">&#9670;&#160;</a></span>totalDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::totalDistance </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function calculates the total distance of a path given a sequence of vertices. If an edge does not exist between two consecutive vertices, it estimates the distance using the Haversine formula. Complexity: O(E) where E is the number of edges in the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of vertices representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the path. </dd></dl>

</div>
</div>
<a id="a74ac3915ab78762e537d45657e30429b" name="a74ac3915ab78762e537d45657e30429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac3915ab78762e537d45657e30429b">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::triangularApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function uses Prim's algorithm to find a minimum spanning tree, then performs a DFS to form a path. It then computes and returns the total distance of this path. The path is also printed. Complexity: O(ElogE) for Prim's and O(V+E) for DFS, where V is the number of vertices and E is the number of edges.</p>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the resulting path. </dd></dl>

</div>
</div>
<a id="a45f1e9e76bcadbd27addb9c5cc455226" name="a45f1e9e76bcadbd27addb9c5cc455226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f1e9e76bcadbd27addb9c5cc455226">&#9670;&#160;</a></span>tsp_backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tsp_backtrack </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>min_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>costSoFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements the backtracking for the traveling salesman problem. It iteratively explores the graph, marks vertices as visited, and updates the path and minimum cost. Complexity: O(n!) where n is the number of vertices. (since it explores all possible permutations of vertices)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector representing the current path. </td></tr>
    <tr><td class="paramname">visited</td><td>A vector indicating whether each vertex has been visited. </td></tr>
    <tr><td class="paramname">min_cost</td><td>A reference to the minimum cost found so far. </td></tr>
    <tr><td class="paramname">costSoFar</td><td>The cost of the path so far. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/USER/Desktop/Universidade/2ano/DA2/data_structures/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/USER/Desktop/Universidade/2ano/DA2/data_structures/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
